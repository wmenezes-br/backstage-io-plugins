{"version":3,"file":"MockDirectory.cjs.js","sources":["../../src/filesystem/MockDirectory.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport os from 'os';\nimport { isChildPath } from '@backstage/backend-plugin-api';\nimport fs from 'fs-extra';\nimport textextensions from 'textextensions';\nimport {\n  dirname,\n  extname,\n  join as joinPath,\n  resolve as resolvePath,\n  relative as relativePath,\n  win32,\n  posix,\n} from 'path';\n\nconst tmpdirMarker = Symbol('os-tmpdir-mock');\n\n/**\n * A context that allows for more advanced file system operations when writing mock directory content.\n *\n * @public\n */\nexport interface MockDirectoryContentCallbackContext {\n  /** Absolute path to the location of this piece of content on the filesystem */\n  path: string;\n\n  /** Creates a symbolic link at the current location */\n  symlink(target: string): void;\n}\n\n/**\n * A callback that allows for more advanced file system operations when writing mock directory content.\n *\n * @public\n */\nexport type MockDirectoryContentCallback = (\n  ctx: MockDirectoryContentCallbackContext,\n) => void;\n\n/**\n * The content of a mock directory represented by a nested object structure.\n *\n * @remarks\n *\n * When used as input, the keys may contain forward slashes to indicate nested directories.\n * Then returned as output, each directory will always be represented as a separate object.\n *\n * @example\n * ```ts\n * {\n *   'test.txt': 'content',\n *   'sub-dir': {\n *     'file.txt': 'content',\n *     'nested-dir/file.txt': 'content',\n *   },\n *   'empty-dir': {},\n *   'binary-file': Buffer.from([0, 1, 2]),\n * }\n * ```\n *\n * @public\n */\nexport type MockDirectoryContent = {\n  [name in string]:\n    | MockDirectoryContent\n    | string\n    | Buffer\n    | MockDirectoryContentCallback;\n};\n\n/**\n * Options for {@link MockDirectory.content}.\n *\n * @public\n */\nexport interface MockDirectoryContentOptions {\n  /**\n   * The path to read content from. Defaults to the root of the mock directory.\n   *\n   * An absolute path can also be provided, as long as it is a child path of the mock directory.\n   */\n  path?: string;\n\n  /**\n   * Whether or not to return files as text rather than buffers.\n   *\n   * Defaults to checking the file extension against a list of known text extensions.\n   */\n  shouldReadAsText?: boolean | ((path: string, buffer: Buffer) => boolean);\n}\n\n/**\n * A utility for creating a mock directory that is automatically cleaned up.\n *\n * @public\n */\nexport interface MockDirectory {\n  /**\n   * The path to the root of the mock directory\n   */\n  readonly path: string;\n\n  /**\n   * Resolves a path relative to the root of the mock directory.\n   */\n  resolve(...paths: string[]): string;\n\n  /**\n   * Sets the content of the mock directory. This will remove any existing content.\n   *\n   * @example\n   * ```ts\n   * mockDir.setContent({\n   *   'test.txt': 'content',\n   *   'sub-dir': {\n   *     'file.txt': 'content',\n   *     'nested-dir/file.txt': 'content',\n   *   },\n   *   'empty-dir': {},\n   *   'binary-file': Buffer.from([0, 1, 2]),\n   * });\n   * ```\n   */\n  setContent(root: MockDirectoryContent): void;\n\n  /**\n   * Adds content of the mock directory. This will overwrite existing files.\n   *\n   * @example\n   * ```ts\n   * mockDir.addContent({\n   *   'test.txt': 'content',\n   *   'sub-dir': {\n   *     'file.txt': 'content',\n   *     'nested-dir/file.txt': 'content',\n   *   },\n   *   'empty-dir': {},\n   *   'binary-file': Buffer.from([0, 1, 2]),\n   * });\n   * ```\n   */\n  addContent(root: MockDirectoryContent): void;\n\n  /**\n   * Reads the content of the mock directory.\n   *\n   * @remarks\n   *\n   * Text files will be returned as strings, while binary files will be returned as buffers.\n   * By default the file extension is used to determine whether a file should be read as text.\n   *\n   * @example\n   * ```ts\n   * expect(mockDir.content()).toEqual({\n   *   'test.txt': 'content',\n   *   'sub-dir': {\n   *     'file.txt': 'content',\n   *     'nested-dir': {\n   *       'file.txt': 'content',\n   *     },\n   *   },\n   *   'empty-dir': {},\n   *   'binary-file': Buffer.from([0, 1, 2]),\n   * });\n   * ```\n   */\n  content(\n    options?: MockDirectoryContentOptions,\n  ): MockDirectoryContent | undefined;\n\n  /**\n   * Clears the content of the mock directory, ensuring that the directory itself exists.\n   */\n  clear(): void;\n\n  /**\n   * Removes the mock directory and all its contents.\n   */\n  remove(): void;\n}\n\n/** @internal */\ntype MockEntry =\n  | {\n      type: 'file';\n      path: string;\n      content: Buffer;\n    }\n  | {\n      type: 'dir';\n      path: string;\n    }\n  | {\n      type: 'callback';\n      path: string;\n      callback: MockDirectoryContentCallback;\n    };\n\n/** @internal */\nclass MockDirectoryImpl {\n  readonly #root: string;\n\n  constructor(root: string) {\n    this.#root = root;\n  }\n\n  get path(): string {\n    return this.#root;\n  }\n\n  resolve(...paths: string[]): string {\n    return resolvePath(this.#root, ...paths);\n  }\n\n  setContent(root: MockDirectoryContent): void {\n    this.remove();\n\n    return this.addContent(root);\n  }\n\n  addContent(root: MockDirectoryContent): void {\n    const entries = this.#transformInput(root);\n\n    for (const entry of entries) {\n      const fullPath = resolvePath(this.#root, entry.path);\n      if (!isChildPath(this.#root, fullPath)) {\n        throw new Error(\n          `Provided path must resolve to a child path of the mock directory, got '${fullPath}'`,\n        );\n      }\n\n      if (entry.type === 'dir') {\n        fs.ensureDirSync(fullPath);\n      } else if (entry.type === 'file') {\n        fs.ensureDirSync(dirname(fullPath));\n        fs.writeFileSync(fullPath, entry.content);\n      } else if (entry.type === 'callback') {\n        fs.ensureDirSync(dirname(fullPath));\n        entry.callback({\n          path: fullPath,\n          symlink(target: string) {\n            fs.symlinkSync(target, fullPath);\n          },\n        });\n      }\n    }\n  }\n\n  content(\n    options?: MockDirectoryContentOptions,\n  ): MockDirectoryContent | undefined {\n    const shouldReadAsText =\n      (typeof options?.shouldReadAsText === 'boolean'\n        ? () => options?.shouldReadAsText\n        : options?.shouldReadAsText) ??\n      ((path: string) => textextensions.includes(extname(path).slice(1)));\n\n    const root = resolvePath(this.#root, options?.path ?? '');\n    if (!isChildPath(this.#root, root)) {\n      throw new Error(\n        `Provided path must resolve to a child path of the mock directory, got '${root}'`,\n      );\n    }\n\n    function read(path: string): MockDirectoryContent | undefined {\n      if (!fs.pathExistsSync(path)) {\n        return undefined;\n      }\n\n      const entries = fs.readdirSync(path, { withFileTypes: true });\n      return Object.fromEntries(\n        entries.map(entry => {\n          const fullPath = resolvePath(path, entry.name);\n\n          if (entry.isDirectory()) {\n            return [entry.name, read(fullPath)];\n          }\n          const content = fs.readFileSync(fullPath);\n          const relativePosixPath = relativePath(root, fullPath)\n            .split(win32.sep)\n            .join(posix.sep);\n\n          if (shouldReadAsText(relativePosixPath, content)) {\n            return [entry.name, content.toString('utf8')];\n          }\n          return [entry.name, content];\n        }),\n      );\n    }\n\n    return read(root);\n  }\n\n  clear = (): void => {\n    this.setContent({});\n  };\n\n  remove = (): void => {\n    fs.rmSync(this.#root, { recursive: true, force: true, maxRetries: 10 });\n  };\n\n  #transformInput(input: MockDirectoryContent[string]): MockEntry[] {\n    const entries: MockEntry[] = [];\n\n    function traverse(node: MockDirectoryContent[string], path: string) {\n      if (typeof node === 'string') {\n        entries.push({\n          type: 'file',\n          path,\n          content: Buffer.from(node, 'utf8'),\n        });\n      } else if (node instanceof Buffer) {\n        entries.push({ type: 'file', path, content: node });\n      } else if (typeof node === 'function') {\n        entries.push({ type: 'callback', path, callback: node });\n      } else {\n        entries.push({ type: 'dir', path });\n        for (const [name, child] of Object.entries(node)) {\n          traverse(child, path ? `${path}/${name}` : name);\n        }\n      }\n    }\n\n    traverse(input, '');\n\n    return entries;\n  }\n}\n\n/**\n * Options for {@link createMockDirectory}.\n *\n * @public\n */\nexport interface CreateMockDirectoryOptions {\n  /**\n   * In addition to creating a temporary directory, also mock `os.tmpdir()` to\n   * return the mock directory path until the end of the test suite.\n   *\n   * When this option is provided the `createMockDirectory` call must happen in\n   * a scope where calling `afterAll` from Jest is allowed\n   *\n   * @returns\n   */\n  mockOsTmpDir?: boolean;\n\n  /**\n   * Initializes the directory with the given content, see {@link MockDirectory.setContent}.\n   */\n  content?: MockDirectoryContent;\n}\n\nconst cleanupCallbacks = new Array<() => void>();\n\nlet registered = false;\nfunction registerTestHooks() {\n  if (typeof afterAll !== 'function') {\n    return;\n  }\n  if (registered) {\n    return;\n  }\n  registered = true;\n\n  afterAll(async () => {\n    for (const callback of cleanupCallbacks) {\n      try {\n        callback();\n      } catch (error) {\n        console.error(\n          `Failed to clean up mock directory after tests, ${error}`,\n        );\n      }\n    }\n    cleanupCallbacks.length = 0;\n  });\n}\n\nregisterTestHooks();\n\n/**\n * Creates a new temporary mock directory that will be removed after the tests have completed.\n *\n * @public\n * @remarks\n *\n * This method is intended to be called outside of any test, either at top-level or\n * within a `describe` block. It will call `afterAll` to make sure that the mock directory\n * is removed after the tests have run.\n *\n * @example\n * ```ts\n * describe('MySubject', () => {\n *   const mockDir = createMockDirectory();\n *\n *   beforeEach(mockDir.clear);\n *\n *   it('should work', () => {\n *     // ... use mockDir\n *   })\n * })\n * ```\n */\nexport function createMockDirectory(\n  options?: CreateMockDirectoryOptions,\n): MockDirectory {\n  const tmpDir = process.env.RUNNER_TEMP || os.tmpdir(); // GitHub Actions\n  const root = fs.mkdtempSync(joinPath(tmpDir, 'backstage-tmp-test-dir-'));\n\n  const mocker = new MockDirectoryImpl(root);\n\n  const origTmpdir = options?.mockOsTmpDir ? os.tmpdir : undefined;\n  if (origTmpdir) {\n    if (Object.hasOwn(origTmpdir, tmpdirMarker)) {\n      throw new Error(\n        'Cannot mock os.tmpdir() when it has already been mocked',\n      );\n    }\n    const mock = Object.assign(() => mocker.path, { [tmpdirMarker]: true });\n    os.tmpdir = mock;\n  }\n\n  // In CI we expect there to be no need to clean up temporary directories\n  const needsCleanup = !process.env.CI;\n  if (needsCleanup) {\n    process.on('beforeExit', mocker.remove);\n  }\n\n  if (needsCleanup) {\n    cleanupCallbacks.push(() => mocker.remove());\n  }\n\n  if (origTmpdir) {\n    afterAll(() => {\n      os.tmpdir = origTmpdir;\n    });\n  }\n\n  if (options?.content) {\n    mocker.setContent(options.content);\n  }\n\n  return mocker;\n}\n"],"names":["resolvePath","isChildPath","fs","dirname","path","textextensions","extname","relativePath","win32","posix","os","joinPath"],"mappings":"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"}