{"version":3,"file":"SchedulerService.cjs.js","sources":["../../../src/services/definitions/SchedulerService.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config, readDurationFromConfig } from '@backstage/config';\nimport { HumanDuration, JsonObject } from '@backstage/types';\nimport { Duration } from 'luxon';\n\n/**\n * A function that can be called as a scheduled task.\n *\n * It may optionally accept an abort signal argument. When the signal triggers,\n * processing should abort and return as quickly as possible.\n *\n * @public\n */\nexport type SchedulerServiceTaskFunction =\n  | ((abortSignal: AbortSignal) => void | Promise<void>)\n  | (() => void | Promise<void>);\n\n/**\n * A semi-opaque type to describe an actively scheduled task.\n *\n * @public\n */\nexport type SchedulerServiceTaskDescriptor = {\n  /**\n   * The unique identifier of the task.\n   */\n  id: string;\n  /**\n   * The scope of the task.\n   */\n  scope: 'global' | 'local';\n  /**\n   * The settings that control the task flow. This is a semi-opaque structure\n   * that is mainly there for debugging purposes. Do not make any assumptions\n   * about the contents of this field.\n   */\n  settings: { version: number } & JsonObject;\n};\n\n/**\n * Options that control the scheduling of a task.\n *\n * @public\n */\nexport interface SchedulerServiceTaskScheduleDefinition {\n  /**\n   * How often you want the task to run. The system does its best to avoid\n   * overlapping invocations.\n   *\n   * @remarks\n   *\n   * This is the best effort value; under some circumstances there can be\n   * deviations. For example, if the task runtime is longer than the frequency\n   * and the timeout has not been given or not been exceeded yet, the next\n   * invocation of this task will be delayed until after the previous one\n   * finishes.\n   *\n   * This is a required field.\n   */\n  frequency:\n    | {\n        /**\n         * A crontab style string.\n         *\n         * @remarks\n         *\n         * Overview:\n         *\n         * ```\n         *   ┌────────────── second (optional)\n         *   │ ┌──────────── minute\n         *   │ │ ┌────────── hour\n         *   │ │ │ ┌──────── day of month\n         *   │ │ │ │ ┌────── month\n         *   │ │ │ │ │ ┌──── day of week\n         *   │ │ │ │ │ │\n         *   │ │ │ │ │ │\n         *   * * * * * *\n         * ```\n         */\n        cron: string;\n      }\n    | Duration\n    | HumanDuration\n    | { trigger: 'manual' };\n\n  /**\n   * The maximum amount of time that a single task invocation can take, before\n   * it's considered timed out and gets \"released\" such that a new invocation\n   * is permitted to take place (possibly, then, on a different worker).\n   */\n  timeout: Duration | HumanDuration;\n\n  /**\n   * The amount of time that should pass before the first invocation happens.\n   *\n   * @remarks\n   *\n   * This can be useful in cold start scenarios to stagger or delay some heavy\n   * compute jobs. If no value is given for this field then the first invocation\n   * will happen as soon as possible according to the cadence.\n   *\n   * NOTE: This is a per-worker delay. If you have a cluster of workers all\n   * collaborating on a task that has its `scope` field set to `'global'`, then\n   * you may still see the task being processed by other long-lived workers,\n   * while any given single worker is in its initial sleep delay time e.g. after\n   * a deployment. Therefore, this parameter is not useful for \"globally\" pausing\n   * work; its main intended use is for individual machines to get a chance to\n   * reach some equilibrium at startup before triggering heavy batch workloads.\n   */\n  initialDelay?: Duration | HumanDuration;\n\n  /**\n   * Sets the scope of concurrency control / locking to apply for invocations of\n   * this task.\n   *\n   * @remarks\n   *\n   * When the scope is set to the default value `'global'`, the scheduler will\n   * attempt to ensure that only one worker machine runs the task at a time,\n   * according to the given cadence. This means that as the number of worker\n   * hosts increases, the invocation frequency of this task will not go up.\n   * Instead, the load is spread randomly across hosts. This setting is useful\n   * for tasks that access shared resources, for example catalog ingestion tasks\n   * where you do not want many machines to repeatedly import the same data and\n   * trample over each other.\n   *\n   * When the scope is set to `'local'`, there is no concurrency control across\n   * hosts. Each host runs the task according to the given cadence similarly to\n   * `setInterval`, but the runtime ensures that there are no overlapping runs.\n   *\n   * @defaultValue 'global'\n   */\n  scope?: 'global' | 'local';\n}\n\n/**\n * Config options for {@link SchedulerServiceTaskScheduleDefinition}\n * that control the scheduling of a task.\n *\n * @public\n */\nexport interface SchedulerServiceTaskScheduleDefinitionConfig {\n  /**\n   * How often you want the task to run. The system does its best to avoid\n   * overlapping invocations.\n   *\n   * @remarks\n   *\n   * This is the best effort value; under some circumstances there can be\n   * deviations. For example, if the task runtime is longer than the frequency\n   * and the timeout has not been given or not been exceeded yet, the next\n   * invocation of this task will be delayed until after the previous one\n   * finishes.\n   *\n   * This is a required field.\n   */\n  frequency:\n    | {\n        /**\n         * A crontab style string.\n         *\n         * @remarks\n         *\n         * Overview:\n         *\n         * ```\n         *   ┌────────────── second (optional)\n         *   │ ┌──────────── minute\n         *   │ │ ┌────────── hour\n         *   │ │ │ ┌──────── day of month\n         *   │ │ │ │ ┌────── month\n         *   │ │ │ │ │ ┌──── day of week\n         *   │ │ │ │ │ │\n         *   │ │ │ │ │ │\n         *   * * * * * *\n         * ```\n         */\n        cron: string;\n      }\n    | string\n    | HumanDuration\n    /**\n     * This task will only run when manually triggered with the `triggerTask` method; no automatic\n     * scheduling. This is useful for locking of global tasks that should not be run concurrently.\n     */\n    | { trigger: 'manual' };\n\n  /**\n   * The maximum amount of time that a single task invocation can take, before\n   * it's considered timed out and gets \"released\" such that a new invocation\n   * is permitted to take place (possibly, then, on a different worker).\n   */\n  timeout: string | HumanDuration;\n\n  /**\n   * The amount of time that should pass before the first invocation happens.\n   *\n   * @remarks\n   *\n   * This can be useful in cold start scenarios to stagger or delay some heavy\n   * compute jobs. If no value is given for this field then the first invocation\n   * will happen as soon as possible according to the cadence.\n   *\n   * NOTE: This is a per-worker delay. If you have a cluster of workers all\n   * collaborating on a task that has its `scope` field set to `'global'`, then\n   * you may still see the task being processed by other long-lived workers,\n   * while any given single worker is in its initial sleep delay time e.g. after\n   * a deployment. Therefore, this parameter is not useful for \"globally\" pausing\n   * work; its main intended use is for individual machines to get a chance to\n   * reach some equilibrium at startup before triggering heavy batch workloads.\n   */\n  initialDelay?: string | HumanDuration;\n\n  /**\n   * Sets the scope of concurrency control / locking to apply for invocations of\n   * this task.\n   *\n   * @remarks\n   *\n   * When the scope is set to the default value `'global'`, the scheduler will\n   * attempt to ensure that only one worker machine runs the task at a time,\n   * according to the given cadence. This means that as the number of worker\n   * hosts increases, the invocation frequency of this task will not go up.\n   * Instead, the load is spread randomly across hosts. This setting is useful\n   * for tasks that access shared resources, for example catalog ingestion tasks\n   * where you do not want many machines to repeatedly import the same data and\n   * trample over each other.\n   *\n   * When the scope is set to `'local'`, there is no concurrency control across\n   * hosts. Each host runs the task according to the given cadence similarly to\n   * `setInterval`, but the runtime ensures that there are no overlapping runs.\n   *\n   * @defaultValue 'global'\n   */\n  scope?: 'global' | 'local';\n}\n\n/**\n * Options that apply to the invocation of a given task.\n *\n * @public\n */\nexport interface SchedulerServiceTaskInvocationDefinition {\n  /**\n   * A unique ID (within the scope of the plugin) for the task.\n   */\n  id: string;\n\n  /**\n   * The actual task function to be invoked regularly.\n   */\n  fn: SchedulerServiceTaskFunction;\n\n  /**\n   * An abort signal that, when triggered, will stop the recurring execution of\n   * the task.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * A previously prepared task schedule, ready to be invoked.\n *\n * @public\n */\nexport interface SchedulerServiceTaskRunner {\n  /**\n   * Takes the schedule and executes an actual task using it.\n   *\n   * @param task - The actual runtime properties of the task\n   */\n  run(task: SchedulerServiceTaskInvocationDefinition): Promise<void>;\n}\n\n/**\n * Deals with the scheduling of distributed tasks, for a given plugin.\n *\n * See the {@link https://backstage.io/docs/backend-system/core-services/scheduler | service documentation} for more details.\n *\n * @public\n */\nexport interface SchedulerService {\n  /**\n   * Manually triggers a task by ID.\n   *\n   * If the task doesn't exist, a NotFoundError is thrown. If the task is\n   * currently running, a ConflictError is thrown.\n   *\n   * @param id - The task ID\n   */\n  triggerTask(id: string): Promise<void>;\n\n  /**\n   * Schedules a task function for recurring runs.\n   *\n   * @remarks\n   *\n   * The `scope` task field controls whether to use coordinated exclusive\n   * invocation across workers, or to just coordinate within the current worker.\n   *\n   * This convenience method performs both the scheduling and invocation in one\n   * go.\n   *\n   * @param task - The task definition\n   */\n  scheduleTask(\n    task: SchedulerServiceTaskScheduleDefinition &\n      SchedulerServiceTaskInvocationDefinition,\n  ): Promise<void>;\n\n  /**\n   * Creates a scheduled but dormant recurring task, ready to be launched at a\n   * later time.\n   *\n   * @remarks\n   *\n   * This method is useful for pre-creating a schedule in outer code to be\n   * passed into an inner implementation, such that the outer code controls\n   * scheduling while inner code controls implementation.\n   *\n   * @param schedule - The task schedule\n   */\n  createScheduledTaskRunner(\n    schedule: SchedulerServiceTaskScheduleDefinition,\n  ): SchedulerServiceTaskRunner;\n\n  /**\n   * Returns all scheduled tasks registered to this scheduler.\n   *\n   * @remarks\n   *\n   * This method is useful for triggering tasks manually using the triggerTask\n   * functionality. Note that the returned tasks contain only tasks that have\n   * been initialized in this instance of the scheduler.\n   *\n   * @returns Scheduled tasks\n   */\n  getScheduledTasks(): Promise<SchedulerServiceTaskDescriptor[]>;\n}\n\nfunction readDuration(config: Config, key: string): HumanDuration {\n  if (typeof config.get(key) === 'string') {\n    const value = config.getString(key);\n    const duration = Duration.fromISO(value);\n    if (!duration.isValid) {\n      throw new Error(`Invalid duration: ${value}`);\n    }\n    return duration.toObject();\n  }\n\n  return readDurationFromConfig(config, { key });\n}\n\nfunction readFrequency(\n  config: Config,\n  key: string,\n): { cron: string } | HumanDuration | { trigger: 'manual' } {\n  const value = config.get(key);\n  if (typeof value === 'object' && (value as { cron?: string }).cron) {\n    return value as { cron: string };\n  }\n  if (\n    typeof value === 'object' &&\n    (value as { trigger?: string }).trigger === 'manual'\n  ) {\n    return { trigger: 'manual' };\n  }\n\n  return readDuration(config, key);\n}\n\n/**\n * Reads a {@link SchedulerServiceTaskScheduleDefinition} from config. Expects\n * the config not to be the root config, but the config for the definition.\n *\n * @param config - config for a TaskScheduleDefinition.\n * @public\n */\nexport function readSchedulerServiceTaskScheduleDefinitionFromConfig(\n  config: Config,\n): SchedulerServiceTaskScheduleDefinition {\n  const frequency = readFrequency(config, 'frequency');\n  const timeout = readDuration(config, 'timeout');\n\n  const initialDelay = config.has('initialDelay')\n    ? readDuration(config, 'initialDelay')\n    : undefined;\n\n  const scope = config.getOptionalString('scope');\n  if (scope && !['global', 'local'].includes(scope)) {\n    throw new Error(\n      `Only \"global\" or \"local\" are allowed for TaskScheduleDefinition.scope, but got: ${scope}`,\n    );\n  }\n\n  return {\n    frequency,\n    timeout,\n    initialDelay,\n    scope: scope as 'global' | 'local' | undefined,\n  };\n}\n"],"names":["config","Duration","readDurationFromConfig"],"mappings":";;;;;AAoWA,SAAS,YAAA,CAAaA,UAAgB,GAA4B,EAAA;AAChE,EAAA,IAAI,OAAOA,QAAA,CAAO,GAAI,CAAA,GAAG,MAAM,QAAU,EAAA;AACvC,IAAM,MAAA,KAAA,GAAQA,QAAO,CAAA,SAAA,CAAU,GAAG,CAAA,CAAA;AAClC,IAAM,MAAA,QAAA,GAAWC,cAAS,CAAA,OAAA,CAAQ,KAAK,CAAA,CAAA;AACvC,IAAI,IAAA,CAAC,SAAS,OAAS,EAAA;AACrB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAqB,kBAAA,EAAA,KAAK,CAAE,CAAA,CAAA,CAAA;AAAA,KAC9C;AACA,IAAA,OAAO,SAAS,QAAS,EAAA,CAAA;AAAA,GAC3B;AAEA,EAAA,OAAOC,6BAAuB,CAAAF,QAAA,EAAQ,EAAE,GAAA,EAAK,CAAA,CAAA;AAC/C,CAAA;AAEA,SAAS,aAAA,CACP,QACA,GAC0D,EAAA;AAC1D,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,GAAA,CAAI,GAAG,CAAA,CAAA;AAC5B,EAAA,IAAI,OAAO,KAAA,KAAU,QAAa,IAAA,KAAA,CAA4B,IAAM,EAAA;AAClE,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AACA,EAAA,IACE,OAAO,KAAA,KAAU,QAChB,IAAA,KAAA,CAA+B,YAAY,QAC5C,EAAA;AACA,IAAO,OAAA,EAAE,SAAS,QAAS,EAAA,CAAA;AAAA,GAC7B;AAEA,EAAO,OAAA,YAAA,CAAa,QAAQ,GAAG,CAAA,CAAA;AACjC,CAAA;AASO,SAAS,qDACd,MACwC,EAAA;AACxC,EAAM,MAAA,SAAA,GAAY,aAAc,CAAA,MAAA,EAAQ,WAAW,CAAA,CAAA;AACnD,EAAM,MAAA,OAAA,GAAU,YAAa,CAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAE9C,EAAM,MAAA,YAAA,GAAe,OAAO,GAAI,CAAA,cAAc,IAC1C,YAAa,CAAA,MAAA,EAAQ,cAAc,CACnC,GAAA,KAAA,CAAA,CAAA;AAEJ,EAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,iBAAA,CAAkB,OAAO,CAAA,CAAA;AAC9C,EAAI,IAAA,KAAA,IAAS,CAAC,CAAC,QAAA,EAAU,OAAO,CAAE,CAAA,QAAA,CAAS,KAAK,CAAG,EAAA;AACjD,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,mFAAmF,KAAK,CAAA,CAAA;AAAA,KAC1F,CAAA;AAAA,GACF;AAEA,EAAO,OAAA;AAAA,IACL,SAAA;AAAA,IACA,OAAA;AAAA,IACA,YAAA;AAAA,IACA,KAAA;AAAA,GACF,CAAA;AACF;;;;"}