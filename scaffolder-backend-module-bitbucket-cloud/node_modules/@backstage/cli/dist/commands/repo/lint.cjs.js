'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var crypto = require('crypto');
var path = require('path');
var cliNode = require('@backstage/cli-node');
var paths = require('../../lib/paths.cjs.js');
var parallel = require('../../lib/parallel.cjs.js');
var optionsParser = require('./optionsParser.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function depCount(pkg) {
  const deps = pkg.dependencies ? Object.keys(pkg.dependencies).length : 0;
  const devDeps = pkg.devDependencies ? Object.keys(pkg.devDependencies).length : 0;
  return deps + devDeps;
}
const CACHE_FILE_NAME = "lint-cache.json";
async function readCache(dir) {
  try {
    const data = await fs__default.default.readJson(path.resolve(dir, CACHE_FILE_NAME));
    if (!Array.isArray(data)) {
      return void 0;
    }
    if (data.some((x) => typeof x !== "string")) {
      return void 0;
    }
    return data;
  } catch {
    return void 0;
  }
}
async function writeCache(dir, cache) {
  await fs__default.default.mkdirp(dir);
  await fs__default.default.writeJson(path.resolve(dir, CACHE_FILE_NAME), cache, { spaces: 2 });
}
async function command(opts, cmd) {
  let packages = await cliNode.PackageGraph.listTargetPackages();
  const cacheDir = path.resolve(
    opts.successCacheDir ?? "node_modules/.cache/backstage-cli"
  );
  const cacheContext = opts.successCache ? {
    cache: await readCache(cacheDir),
    lockfile: await cliNode.Lockfile.load(paths.paths.resolveTargetRoot("yarn.lock"))
  } : void 0;
  if (opts.since) {
    const graph = cliNode.PackageGraph.fromPackages(packages);
    packages = await graph.listChangedPackages({
      ref: opts.since,
      analyzeLockfile: true
    });
  }
  packages.sort((a, b) => depCount(b.packageJson) - depCount(a.packageJson));
  if (opts.format === "eslint-formatter-friendly") {
    process.chdir(paths.paths.targetRoot);
  }
  if (!process.env.FORCE_COLOR) {
    process.env.FORCE_COLOR = "1";
  }
  const parseLintScript = optionsParser.createScriptOptionsParser(cmd, ["package", "lint"]);
  const items = await Promise.all(
    packages.map(async (pkg) => {
      const lintOptions = parseLintScript(pkg.packageJson.scripts?.lint);
      const base = {
        fullDir: pkg.dir,
        relativeDir: path.relative(paths.paths.targetRoot, pkg.dir),
        lintOptions,
        parentHash: void 0
      };
      if (!cacheContext) {
        return base;
      }
      const hash = crypto.createHash("sha1");
      hash.update(
        cacheContext.lockfile.getDependencyTreeHash(pkg.packageJson.name)
      );
      hash.update("\0");
      hash.update(JSON.stringify(lintOptions ?? {}));
      hash.update("\0");
      hash.update(process.version);
      hash.update("\0");
      hash.update("v1");
      return {
        ...base,
        parentHash: hash.digest("hex")
      };
    })
  );
  const resultsList = await parallel.runWorkerQueueThreads({
    items: items.filter((item) => item.lintOptions),
    // Filter out packages without lint script
    workerData: {
      fix: Boolean(opts.fix),
      format: opts.format,
      shouldCache: Boolean(cacheContext),
      successCache: cacheContext?.cache,
      rootDir: paths.paths.targetRoot
    },
    workerFactory: async ({
      fix,
      format,
      shouldCache,
      successCache,
      rootDir
    }) => {
      const { ESLint } = require("eslint");
      const crypto = require("crypto");
      const globby = require("globby");
      const { readFile } = require("fs/promises");
      const { relative: workerRelativePath } = require("path");
      return async ({
        fullDir,
        relativeDir,
        lintOptions,
        parentHash
      }) => {
        process.cwd = () => fullDir;
        const start = Date.now();
        const eslint = new ESLint({
          cwd: fullDir,
          fix,
          extensions: ["js", "jsx", "ts", "tsx", "mjs", "cjs"]
        });
        let sha = void 0;
        if (shouldCache) {
          const result = await globby(relativeDir, {
            gitignore: true,
            onlyFiles: true,
            cwd: rootDir
          });
          const hash = crypto.createHash("sha1");
          hash.update(parentHash);
          hash.update("\0");
          for (const path of result.sort()) {
            if (await eslint.isPathIgnored(path)) {
              continue;
            }
            hash.update(workerRelativePath(fullDir, path));
            hash.update("\0");
            hash.update(await readFile(path));
            hash.update("\0");
            hash.update(
              JSON.stringify(await eslint.calculateConfigForFile(path))
            );
            hash.update("\0");
          }
          sha = await hash.digest("hex");
          if (successCache?.includes(sha)) {
            console.log(`Skipped ${relativeDir} due to cache hit`);
            return { relativeDir, sha, failed: false };
          }
        }
        const formatter = await eslint.loadFormatter(format);
        const results = await eslint.lintFiles(["."]);
        const count = String(results.length).padStart(3);
        const time = ((Date.now() - start) / 1e3).toFixed(2);
        console.log(`Checked ${count} files in ${relativeDir} ${time}s`);
        if (fix) {
          await ESLint.outputFixes(results);
        }
        const maxWarnings = lintOptions?.maxWarnings ?? 0;
        const resultText = formatter.format(results);
        const failed2 = results.some((r) => r.errorCount > 0) || results.reduce((current, next) => current + next.warningCount, 0) > maxWarnings;
        return {
          relativeDir,
          resultText,
          failed: failed2,
          sha
        };
      };
    }
  });
  const outputSuccessCache = [];
  let failed = false;
  for (const {
    relativeDir,
    resultText,
    failed: runFailed,
    sha
  } of resultsList) {
    if (runFailed) {
      console.log(chalk__default.default.red(`Lint failed in ${relativeDir}`));
      failed = true;
      if (resultText) {
        console.log();
        console.log(resultText.trimStart());
      }
    } else if (sha) {
      outputSuccessCache.push(sha);
    }
  }
  if (cacheContext) {
    await writeCache(cacheDir, outputSuccessCache);
  }
  if (failed) {
    process.exit(1);
  }
}

exports.command = command;
//# sourceMappingURL=lint.cjs.js.map
