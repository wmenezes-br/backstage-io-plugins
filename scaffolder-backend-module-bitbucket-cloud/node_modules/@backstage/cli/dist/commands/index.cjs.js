'use strict';

var errors = require('@backstage/errors');
var errors$1 = require('../lib/errors.cjs.js');

const configOption = [
  "--config <path>",
  "Config files to load instead of app-config.yaml",
  (opt, opts) => opts ? [...opts, opt] : [opt],
  Array()
];
function registerRepoCommand(program) {
  const command = program.command("repo [command]").description("Command that run across an entire Backstage project");
  command.command("build").description(
    "Build packages in the project, excluding bundled app and backend packages."
  ).option(
    "--all",
    "Build all packages, including bundled app and backend packages."
  ).option(
    "--since <ref>",
    "Only build packages and their dev dependents that changed since the specified ref"
  ).option(
    "--minify",
    "Minify the generated code. Does not apply to app package (app is minified by default)."
  ).action(lazy(() => Promise.resolve().then(function () { return require('./repo/build.cjs.js'); }).then((m) => m.command)));
  command.command("lint").description("Lint all packages in the project").option(
    "--format <format>",
    "Lint report output format",
    "eslint-formatter-friendly"
  ).option(
    "--since <ref>",
    "Only lint packages that changed since the specified ref"
  ).option(
    "--successCache",
    "Enable success caching, which skips running tests for unchanged packages that were successful in the previous run"
  ).option(
    "--successCacheDir <path>",
    "Set the success cache location, (default: node_modules/.cache/backstage-cli)"
  ).option("--fix", "Attempt to automatically fix violations").action(lazy(() => Promise.resolve().then(function () { return require('./repo/lint.cjs.js'); }).then((m) => m.command)));
  command.command("fix").description("Automatically fix packages in the project").option(
    "--publish",
    "Enable additional fixes that only apply when publishing packages"
  ).option(
    "--check",
    "Fail if any packages would have been changed by the command"
  ).action(lazy(() => Promise.resolve().then(function () { return require('./repo/fix.cjs.js'); }).then((m) => m.command)));
  command.command("clean").description("Delete cache and output directories").action(lazy(() => Promise.resolve().then(function () { return require('./repo/clean.cjs.js'); }).then((m) => m.command)));
  command.command("list-deprecations").description("List deprecations").option("--json", "Output as JSON").action(
    lazy(() => Promise.resolve().then(function () { return require('./repo/list-deprecations.cjs.js'); }).then((m) => m.command))
  );
  command.command("test").allowUnknownOption(true).option(
    "--since <ref>",
    "Only test packages that changed since the specified ref"
  ).option(
    "--successCache",
    "Enable success caching, which skips running tests for unchanged packages that were successful in the previous run"
  ).option(
    "--successCacheDir <path>",
    "Set the success cache location, (default: node_modules/.cache/backstage-cli)"
  ).option(
    "--jest-help",
    "Show help for Jest CLI options, which are passed through"
  ).description("Run tests, forwarding args to Jest, defaulting to watch mode").action(lazy(() => Promise.resolve().then(function () { return require('./repo/test.cjs.js'); }).then((m) => m.command)));
}
function registerScriptCommand(program) {
  const command = program.command("package [command]").description("Lifecycle scripts for individual packages");
  command.command("start").description("Start a package for local development").option(...configOption).option("--role <name>", "Run the command with an explicit package role").option("--check", "Enable type checking and linting if available").option("--inspect [host]", "Enable debugger in Node.js environments").option(
    "--inspect-brk [host]",
    "Enable debugger in Node.js environments, breaking before code starts"
  ).option("--require <path>", "Add a --require argument to the node process").action(lazy(() => Promise.resolve().then(function () { return require('./start/index.cjs.js'); }).then((m) => m.command)));
  command.command("build").description("Build a package for production deployment or publishing").option("--role <name>", "Run the command with an explicit package role").option(
    "--minify",
    "Minify the generated code. Does not apply to app package (app is minified by default)."
  ).option(
    "--skip-build-dependencies",
    "Skip the automatic building of local dependencies. Applies to backend packages only."
  ).option(
    "--stats",
    "If bundle stats are available, write them to the output directory. Applies to app packages only."
  ).option(
    "--config <path>",
    "Config files to load instead of app-config.yaml. Applies to app packages only.",
    (opt, opts) => opts ? [...opts, opt] : [opt],
    Array()
  ).action(lazy(() => Promise.resolve().then(function () { return require('./build/index.cjs.js'); }).then((m) => m.command)));
  command.command("lint [directories...]").option(
    "--format <format>",
    "Lint report output format",
    "eslint-formatter-friendly"
  ).option("--fix", "Attempt to automatically fix violations").option(
    "--max-warnings <number>",
    "Fail if more than this number of warnings (default: 0)"
  ).description("Lint a package").action(lazy(() => Promise.resolve().then(function () { return require('./lint.cjs.js'); }).then((m) => m.default)));
  command.command("test").allowUnknownOption(true).helpOption(", --backstage-cli-help").description("Run tests, forwarding args to Jest, defaulting to watch mode").action(lazy(() => Promise.resolve().then(function () { return require('./test.cjs.js'); }).then((m) => m.default)));
  command.command("clean").description("Delete cache directories").action(lazy(() => Promise.resolve().then(function () { return require('./clean/clean.cjs.js'); }).then((m) => m.default)));
  command.command("prepack").description("Prepares a package for packaging before publishing").action(lazy(() => Promise.resolve().then(function () { return require('./pack.cjs.js'); }).then((m) => m.pre)));
  command.command("postpack").description("Restores the changes made by the prepack command").action(lazy(() => Promise.resolve().then(function () { return require('./pack.cjs.js'); }).then((m) => m.post)));
}
function registerMigrateCommand(program) {
  const command = program.command("migrate [command]").description("Migration utilities");
  command.command("package-roles").description(`Add package role field to packages that don't have it`).action(lazy(() => Promise.resolve().then(function () { return require('./migrate/packageRole.cjs.js'); }).then((m) => m.default)));
  command.command("package-scripts").description("Set package scripts according to each package role").action(
    lazy(() => Promise.resolve().then(function () { return require('./migrate/packageScripts.cjs.js'); }).then((m) => m.command))
  );
  command.command("package-exports").description("Synchronize package subpath export definitions").action(
    lazy(() => Promise.resolve().then(function () { return require('./migrate/packageExports.cjs.js'); }).then((m) => m.command))
  );
  command.command("package-lint-configs").description(
    "Migrates all packages to use @backstage/cli/config/eslint-factory"
  ).action(
    lazy(() => Promise.resolve().then(function () { return require('./migrate/packageLintConfigs.cjs.js'); }).then((m) => m.command))
  );
  command.command("react-router-deps").description(
    "Migrates the react-router dependencies for all packages to be peer dependencies"
  ).action(
    lazy(() => Promise.resolve().then(function () { return require('./migrate/reactRouterDeps.cjs.js'); }).then((m) => m.command))
  );
}
function registerCommands(program) {
  program.command("new").storeOptionsAsProperties(false).description(
    "Open up an interactive guide to creating new things in your app"
  ).option(
    "--select <name>",
    "Select the thing you want to be creating upfront"
  ).option(
    "--option <name>=<value>",
    "Pre-fill options for the creation process",
    (opt, arr) => [...arr, opt],
    []
  ).option("--scope <scope>", "The scope to use for new packages").option(
    "--npm-registry <URL>",
    "The package registry to use for new packages"
  ).option(
    "--baseVersion <version>",
    "The version to use for any new packages (default: 0.1.0)"
  ).option(
    "--license <license>",
    "The license to use for any new packages (default: Apache-2.0)"
  ).option("--no-private", "Do not mark new packages as private").action(lazy(() => Promise.resolve().then(function () { return require('./new/new.cjs.js'); }).then((m) => m.default)));
  program.command("config:docs").option(
    "--package <name>",
    "Only include the schema that applies to the given package"
  ).description("Browse the configuration reference documentation").action(lazy(() => Promise.resolve().then(function () { return require('./config/docs.cjs.js'); }).then((m) => m.default)));
  program.command("config:print").option(
    "--package <name>",
    "Only load config schema that applies to the given package"
  ).option("--lax", "Do not require environment variables to be set").option("--frontend", "Print only the frontend configuration").option("--with-secrets", "Include secrets in the printed configuration").option(
    "--format <format>",
    "Format to print the configuration in, either json or yaml [yaml]"
  ).option(...configOption).description("Print the app configuration for the current package").action(lazy(() => Promise.resolve().then(function () { return require('./config/print.cjs.js'); }).then((m) => m.default)));
  program.command("config:check").option(
    "--package <name>",
    "Only load config schema that applies to the given package"
  ).option("--lax", "Do not require environment variables to be set").option("--frontend", "Only validate the frontend configuration").option("--deprecated", "Output deprecated configuration settings").option(
    "--strict",
    "Enable strict config validation, forbidding errors and unknown keys"
  ).option(...configOption).description(
    "Validate that the given configuration loads and matches schema"
  ).action(lazy(() => Promise.resolve().then(function () { return require('./config/validate.cjs.js'); }).then((m) => m.default)));
  program.command("config:schema").option(
    "--package <name>",
    "Only output config schema that applies to the given package"
  ).option(
    "--format <format>",
    "Format to print the schema in, either json or yaml [yaml]"
  ).option("--merge", "Print the config schemas merged", true).option("--no-merge", "Print the config schemas not merged").description("Print configuration schema").action(lazy(() => Promise.resolve().then(function () { return require('./config/schema.cjs.js'); }).then((m) => m.default)));
  registerRepoCommand(program);
  registerScriptCommand(program);
  registerMigrateCommand(program);
  program.command("versions:bump").option(
    "--pattern <glob>",
    "Override glob for matching packages to upgrade"
  ).option(
    "--release <version|next|main>",
    "Bump to a specific Backstage release line or version",
    "main"
  ).option("--skip-install", "Skips yarn install step").option("--skip-migrate", "Skips migration of any moved packages").description("Bump Backstage packages to the latest versions").action(lazy(() => Promise.resolve().then(function () { return require('./versions/bump.cjs.js'); }).then((m) => m.default)));
  program.command("versions:migrate").option(
    "--pattern <glob>",
    "Override glob for matching packages to upgrade"
  ).option(
    "--skip-code-changes",
    "Skip code changes and only update package.json files"
  ).description(
    "Migrate any plugins that have been moved to the @backstage-community namespace automatically"
  ).action(lazy(() => Promise.resolve().then(function () { return require('./versions/migrate.cjs.js'); }).then((m) => m.default)));
  program.command("build-workspace <workspace-dir> [packages...]").option(
    "--alwaysYarnPack",
    "Force workspace output to be a result of running `yarn pack` on each package (warning: very slow)"
  ).description("Builds a temporary dist workspace from the provided packages").action(lazy(() => Promise.resolve().then(function () { return require('./buildWorkspace.cjs.js'); }).then((m) => m.default)));
  program.command("create-github-app <github-org>").description("Create new GitHub App in your organization.").action(lazy(() => Promise.resolve().then(function () { return require('./create-github-app/index.cjs.js'); }).then((m) => m.default)));
  program.command("info").description("Show helpful information for debugging and reporting bugs").action(lazy(() => Promise.resolve().then(function () { return require('./info.cjs.js'); }).then((m) => m.default)));
  program.command("create").allowUnknownOption(true).action(removed("use 'backstage-cli new' instead"));
  program.command("create-plugin").allowUnknownOption(true).action(removed("use 'backstage-cli new' instead"));
  program.command("plugin:diff").allowUnknownOption(true).action(removed("use 'backstage-cli fix' instead"));
  program.command("test").allowUnknownOption(true).action(
    removed(
      "use 'backstage-cli repo test' or 'backstage-cli package test' instead"
    )
  );
  program.command("clean").allowUnknownOption(true).action(removed("use 'backstage-cli package clean' instead"));
  program.command("versions:check").allowUnknownOption(true).action(removed("use 'yarn dedupe' or 'yarn-deduplicate' instead"));
  program.command("install").allowUnknownOption(true).action(removed());
  program.command("onboard").allowUnknownOption(true).action(removed());
}
function removed(message) {
  return () => {
    console.error(
      message ? `This command has been removed, ${message}` : "This command has been removed"
    );
    process.exit(1);
  };
}
function lazy(getActionFunc) {
  return async (...args) => {
    try {
      const actionFunc = await getActionFunc();
      await actionFunc(...args);
      process.exit(0);
    } catch (error) {
      errors.assertError(error);
      errors$1.exitWithError(error);
    }
  };
}

exports.registerCommands = registerCommands;
exports.registerMigrateCommand = registerMigrateCommand;
exports.registerRepoCommand = registerRepoCommand;
exports.registerScriptCommand = registerScriptCommand;
//# sourceMappingURL=index.cjs.js.map
